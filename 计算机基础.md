### 计算机基础 ###

---

计算机基础（Java），包括数据结构（刷题），计算机网络，操作系统，数据库，Linux和Git常用操作。



#### 计算机基础（Java） ####

---

**面向对象和面向过程的区别**

（1）面向过程：**面向过程性能高。**因为类的调用需要实例化，开销较大，所以当性能是重要的考察因素的时候，比如单片机、嵌入式开发、Linux等一般采用面向过程开发。

（2）面向对象：**面向对象易维护、易复用、易扩展。**因为面向对象有封装、继承、多态的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。



**Java有哪些特点**

（1）简单易学；（2）面向对象（封装、继承、多态）；（3）平台无关性（jvm实现多平台移植）；（4）可靠性；（5）安全性；（6）支持多线程（C++11之前没有内置的多线程机制，必须调用操作系统的多线程功能来进行程序设计，而java提供了多线程支持）；（7）支持网络编程并且方便；（8）编译与解释并存。



**关于 JVM JDK 和 JRE 最详细通俗的解答**

（1）JVM。Java虚拟机是Java字节码的虚拟机，JVM针对不同操作系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

```
那什么是字节码呢？采用字节码的好处是什么？

	对于这个问题，得先解释源代码的转换过程。人类编写的代码是源代码，只有人能看懂，但是机器看不懂，所以在程序执行之前必须将源代码转换成二进制指令（这是机器能看懂的语言）。

	然后在什么时候将源代码转换成二进制指令呢？不同的编程语言有不同的规定，它们大致分为以下两种：
编译型语言：比如C，C++，Golang，汇编等。必须提前将所有源代码一次性转换成二进制指令，生成一个可执行程序（Windows下生成一个.exe）。可执行程序中包含的就是机器码，即只要我们拥有可执行程序，就可以随时运行，不用再重新编译了，也就是“一次编译，无限次运行”。
* 但是编译型语言一般不能跨平台，不能在不同的操作系统之间随意切换。
1）可执行程序不能跨平台。因为不同操作系统对可执行程序内部结构有着截然不同的要求，彼此之间不能相互兼容（比如.exe文件就不能在Linux平台下运行）。而且不同操作系统之间的不同版本之间也不一定能兼容。
2）源代码不能跨平台。举个例子，C语言中的睡眠函数，Windows下是Sleep()，且参数是毫秒，Linux下是sleep()，参数是秒。再举个例子，long类型，Windows下64位long占4个字节，Linux下64位long占8个字节。

解释型语言：比如Python，JavaScript，Shell等。一边执行一边转换，需要用到哪些源代码就转换哪些源代码，不会生成可执行程序。即每次执行程序都需要将用到的那部分源代码转换成机器码，用不到的不管它，每次执行都可能用到不同的功能，需要转换的源代码也不同。正因为这个原因，解释型语言的执行效率远低于编译型语言，甚至差距是数量级的。但是解释型语言几乎都能跨平台，做到”一次编写，到处运行“，这要归功于解释器。
1）跨平台是指源代码跨平台，而不是解释器跨平台，解释器只是将源代码转换成机器码，就是一个可执行程序，它不能跨平台。官方针对不同的平台开发不同的解释器，在不同的平台，这些解释器会将同一段源代码编译成不同的机器码，解释器帮助我们屏蔽了不同平台之间的差异。


说完上面的编译型语言和解释性语言之后，再来说说Java这种奇葩。
Java和C#是半编译半解释型的语言，源代码先转换成一种中间文件（字节码文件，.class文件），然后再将中间文件拿到虚拟机中执行。Java引领了这种风潮，它的初衷是在跨平台的同时兼顾执行效率。而C#是后来的跟随者，但是C#止步于Windows平台。

字节码(.class)转换为机器码这一步，JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速率会相对比较慢，而且某些热点代码（经常用到的代码）需要经常调用，所以引进了JIT编译器（JIT属于运行时编译）。JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。由于机器码的执行效率高于Java解释器，JIT的加入使得我们经常说Java是编译与解释共存的语言。
```

总结：

Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言的“一次编译，随处可以运行”的关键所在。



**JDK和JRE**

JDK是Java Development Kit，是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（javadoc和jdb）。他能够创建和编译程序。

JRE是java运行时环境。它是运行已编译java程序所需的所有内容的集合，包括JVM，java类库，java命令和一些基础构建。但是，它不能用于创建新程序。

如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。

（但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。）



**Java和C++的区别**

（1）都是面向对象的语言，都支持封装、继承和多态。

（2）java不提供指针来直接访问内存，程序内存更加安全。

（3）java的类都是单继承的，C++支持多重继承；虽然java的类不支持多继承，但是接口支持多继承。

（4）java有自动的内存管理机制，不需要程序员手动释放无用内存。



**Java 应用程序与小程序之间有哪些差别**

简单说应用程序时从主线程启动（也就是main()方法）。

applet小程序没有main()方法，主要是嵌在浏览器页面上运行（调用init()或者run()来启动），嵌入浏览器这点跟flash的小游戏类似。



**什么是 Java 程序的主类 应用程序和小程序的主类有何不同**

一个程序中可以有多个类，但只能有一个是主类。在java应用程序中，这个主类是指包含main()方法的类。而在java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是java程序执行的入口点。



**字符型常量和字符串常量的区别**

（1）形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符。

（2）含义上：字符常量相当于一个整型值（ASCII值），可以参加表示式运算；字符串常量代表一个地址值（该字符串在内存中存放位置）

（3）占内存大小：字符常量只占2个字节；字符串常量占若干个字节（至少一个字符结束标志）（注意：java中char占2个字节）



**构造器 Constructor 是否可被 override**

在讲继承的时候，我们就知道父类的**私有属性**（确切地说，私有属性可以继承，但仅仅是拥有不能改写）和**构造方法**并不能被继承，所以Constructor也就不能被override（重写），但是可以overload（重载），所以你可以看到一个类中有多个构造函数的情况。



**重载和重写的区别**

（1）重载(overload)：发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，**发生在编译时**。

（2）重写(override)：发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private，则子类就不能重写该方法（私有属性仅能拥有不能改写）。



**Java 面向对象编程三大特性: 封装 继承 多态**

（1）封装：把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。如果属性不想被外界访问，大可不必提供方法（但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。）。

（2）继承：使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或者新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

关于继承如下3点请记住：

1.子类拥有父类对象的所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。

2.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。

3.子类可以用自己的方式实现父类的方法。（以后介绍）



（3）多态：是指程序中定义的引用变量所指向的具体类型，和通过该引用变量发出的方法调用，在编程时并不确定，而是在程序运行期间才确定。即一个引用变量到底会指向那个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。



**String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?**

可变性：简单来说，String类中使用final关键字修饰字符数组来保存字符串，private final char value[]，所以String对象是不可变的。而StringBuilder和StringBuffer都继承自AbstractStringBuffer类，在AbstractStringBuilder中也是使用字符数组保存字符串char[] value，但是没有用final关键字修饰，所以这两种对象都是可变的。

（1）线程安全性。

String中对象不可变，可理解为常量，线程安全。AbstractStringBuilder是StringBuffer和StringBuilder的公共父类，并定义了一些字符串的基本操作。StringBuffer对调用的方法添加了同步锁，所以是线程安全的；而StringBuilder没有对方法添加同步锁，所以是非线程安全。

（2）性能。

String：每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。

StringBuffer：每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。

StringBuilder：与StringBuffer相同情况下使用StringBuilder仅能提升15%左右的性能，但是却要冒多线程不安全的风险。

（3）总结。

1.操作少量的数据，适用String。

2.单线程操作字符串缓冲区下大量数据：适用StringBuilder。

3.多线程操作字符串缓冲区下大量数据：适用StringBuffer。



**自动装箱与拆箱**

（1）装箱：将基本类型用它们对应的引用类型包装起来。比如int -> Integer。

（2）拆箱：将封装类型转换为基本数据类型。

通俗的理解。装箱：基本类型转换成封装类型； 拆箱：封装类型转换成基本类型。

1.注意其中存在的陷阱：说下Integer这儿的一个坑，也是比较有意思的地方。初始化Integer后，IntegerCache会缓存[-128,127]之间的数据，这个区间的**上限**（只有上限）可以配置，配置之后可以是[-128, max]。比如Integer.valueOf(200)，在-128和127之间，它会返回一个系统已经生产的cache，否则它会生产一个新的对象出来。所以当它的值超过了区间后，它就会返回新的箱子。

2.另外其他陷阱：比如Integer.valueOf(null)，Integer对象的值可以为null，所以编译器检查时不会出现检查时异常，但是在转换成int的时候就会抛出空指针异常。



**在一个静态方法内调用一个非静态成员为什么是非法的**

由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问费静态变量成员。



**在 Java 中定义一个不做事且没有参数的构造方法的作用**

场景：Java 程序在执行子类的构造方法之前，如果没有用 `super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。（比如我经常写的二叉树代码）

```
class TreeNode{
	int val;
	TreeNode left;
	TreeNode right;
	
	public TreeNode(){}  // 就是这个构造方法
}
```

如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 `super()`来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。



**import java和javax有什么区别**

刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。

所以，实际上java和javax没有区别。这都是一个名字。



**接口和抽象类的区别是什么**

（1）接口的方法默认是public，所有方法在接口中不能有实现（Java 8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。

（2）接口中除了static、final变量，不能有其他变量，而抽象类中不一定。

（3）一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。

（4）接口方法默认修饰符是public，抽象方法可以有public、protected、default这些（抽象方法本身就是为了被重写所有不能有private）。

（5）设计层面来说，抽象是对类的抽象，是一种模板设计；而接口是对行为的抽象，是一种行为规范。



**成员变量与局部变量的区别有哪些**

（1）从语法形式上看。成员变量属于类，局部变量是方法中定义的变量或参数；成员变量可以被public、private、static修饰，而局部变量不能被访问控制修饰符和static修饰；但是它们都能被final所修饰。

（2）从变量在内存中的存储方式来看。如果成员变量被static所修饰，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量存在于栈内存。

（3）从变量在内存中的生存时间上看。成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。

（4）成员变量如果没有被赋初始值，则会自动以类型的默认值赋值（除了被final修饰外，这种情况必须显示地赋值），而局部变量则不会自动赋值。



**创建一个对象用什么运算符?对象实体与对象引用有何不同?**

new运算符。new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。

```
String s = new String("str");
```

这里s就是对象引用，String("str")就是对象，里面的"str"就是实例（实例放在常量池中，也是在堆内存）。

一个对象引用指向0个或1个对象实例（一根绳子可以不系气球，也可以系一个气球）；一个对象实例可以有n个引用指向它（可以用n个绳子拴住一个气球）。



**什么是方法的返回值?返回值在类的方法里的作用是什么?**

方法的返回值是指，我们获取到的某个方法体中的代码执行后产生的结果（前提是该方法可能产生结果）。

返回值的作用：接收出结果，使得它可以用于其他的操作。



**一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?**

主要作用是完成类对象的初始化工作。即时一个类没有生命构造方法，它可以执行，因为也会有默认的不带参数的构造方法完成初始化。



**构造方法有哪些特性**

（1）名字与类名相同。

（2）没有返回值，且不能用void声明。

（3）生成对象时自动执行，无需调用。



**静态方法和实例方法有何不同**

（1）静态方法调用有2中，“类名.方法名”或者“对象名.方法名”，而实例方法只能使用后者。即静态方法无需创建对象即可调用。

（2）静态方法在访问本类的成员时，只允许访问静态成员（静态变量和静态方法），而不允许访问实例成员；但是实例方法无此限制。



**对象的相等与指向他们的引用相等，两者有什么不同?**

对象相等：比较的是内存中存放的内容是否相等；

指向它们的引用相等：比较的是二者的内存地址是否相等。



**在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是?**

帮助子类作初始化工作。



**== 与 equals(重要)**

==：基本数据类型判断的是值是否相等，引用数据类型判断的是内存地址是否相等。

equals：Object类下自带的equals方法，可以重写，因此分为两种情况：

（1）重写了equals方法，比较的是两个对象的属性是否相等。

（2）没有重写equals方法，与==没有差别。

注意：

​	String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

​	当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。



**hashCode 与 equals (重要)**

面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”，这个我还真写过。

（1）hashCode()介绍。hashCode()的作用是获取哈希码，也称为散列码，它实际上是一个int整数。这个哈希码的作用是确定该对象在哈希表中的位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。**hashCode()在散列表中才有用，在其他情况下没用**，散列表中hashCode()的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

（2）为什么要有hashCode。以HashSet为例说明为什么要有hashCode。当把对象加入HashSet时，先计算对象的hashCode，与已经加入HashSet的对象的hashCode比较，如果发现有相同的hashCode值的对象，再调用equals()方法比较二者是否真的相同。如果相同，那么HashSet就不会让这个新来的加入表中；如果不同就会让它重新散列到其他位置。这样大大减少了equals()的比较次数，提高了执行速度。

（3）hashCode()和equals()的相关规定。

1.如果两个对象相等，那么hashCode()一定相同；

2.如果两个对象相等，分别调用equals()返回true；

3.如果两个对象有相同的hashCode()，它们也不一定相等；

4.equals()方法被重写过，那么hashCode()方法必须被重写；

5.hashCode()的默认行为是对堆上的对象产生独特值，如果没有重写hashCode()方法，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。



**为什么Java中只有值传递**

java中只有值传递，没有引用传递。



**简述线程、程序、进程的基本概念。以及他们之间关系是什么?**

（1）程序。程序是包含指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序时静态的代码。

（2）进程。进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序时一个进程从创建、运行到消亡的过程。简单来说，一个进程就是执行中的程序，每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存。

（3）线程。线程是进行执行的基本单位，一个进程的所有任务都在线程中执行。每个进程必须至少得有一条线程，程序启动时会默认开启一条线程，称为主线程或者UI线程。

经典一句话：进程是资源分配（操作系统）的最小单位，线程是cpu调度（处理器调度）的最小单位。

进程之间资源独立，地址空间独立；线程之间资源共享，地址空间共享。



**线程有哪些基本状态?**

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态。

（1）新建(New)。新建一个线程对象。

（2）可运行态(Runnable)。线程对象创建后，其他线程（比如main线程）调用了该对象的start()方法，该状态的线程进入可运行线程池中，等待线程被调度选中，获取cpu的使用权。

（3）运行态(Running)。可运行状态的线程获得了cpu的时间片（time slice），执行程序代码。

（4）等待态(Waiting)。当线程执行wait()方法后，线程进入等待状态，此时需要依靠其他线程的通知才能够返回到可运行(Runnable)状态；而**超时等待(Timed Waiting)**状态相当于等待状态的基础上增加了超时限制，比如通过sleep()或者wait()方法可以将java线程置于timed waiting状态，超时达到时间后，线程将会返回可运行态(Runnable)。

（5）阻塞态(Blocked)。线程因为某种原因（比如调用同步方法时，没有获取到同步锁）放弃了cpu的使用权，即让出了cpu time slice，暂时停止运行。直到线程进入可运行状态(Runnable)，才有机会再次获得cpu time slice，转到运行状态(Running)。

阻塞态分为以下三种：

1.等待阻塞。运行(Running)的线程执行o.wait()方法，JVM会把该线程放入等待队列中。

2.同步阻塞。运行(Running)的线程在争夺同步锁的过程中，被别的线程占用，JVM会把该线程放入锁池。

3.其他阻塞。运行(running)的线程执行Thread.sleep()方法或者t.join()方法，或者发出了I/O请求时，JVM会把线程置为阻塞态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

（6）终止态(Terminated)。线程run()，main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。终止的线程不可再次复生。



**关于 final 关键字的一些总结**

final关键字主要用在3个地方：变量、方法、类。

（1）final变量。基本数据类型的变量，一旦初始化后便不能再更改；引用类型变量，初始化后不能再指向另一个对象。

（2）final方法。两个作用，一，把方法锁定，防止任何继承类修改它的含义；二是java本身的效率问题。

（3）final类。这个类不能被继承，并且final类中的成员方法都会被隐式地指定为final方法。



**Java 中的异常处理**

<img src="https://pics1.baidu.com/feed/8435e5dde71190ef6b44ccd43f628c10fcfa60f9.jpeg?token=d70972c86d0ab4d34237bea847d3d5b8&s=8134ED361B9F41CA525DB9DA020040B1" style="zoom: 67%;" />

在 Java 中，所有的异常都有一个共同的祖先java.lang包中的**Throwable类**。

（1）Throwable： 有两个重要的子类，分别是**Exception（异常）**和**Error（错误）**，二者都是 Java 异常处理的重要子类，各自都包含大量子类。

（2）Error（错误）：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。还有StackOverflow。

（3）Exception（异常）：是程序本身可以处理的异常。Exception 类有一个重要的子类 **RuntimeException**。RuntimeException 异常由Java虚拟机抛出。**NullPointerException**（要访问的变量没有引用任何对象时，抛出该异常）、**ArithmeticException**（算术运算异常，一个整数除以0时，抛出该异常）和 **ArrayIndexOutOfBoundsException** （下标越界异常）。

注意：错误和异常的区别：错误不能被处理，异常能被程序本身处理。



**异常处理总结**

（1）try块。用于捕获异常，其后可接0个或多个catch块，如果没有catch块，则必须跟一个finally块。

（2）catch块。用于处理try捕获到的异常。

（3）finally块。无论是否捕获或处理异常，finally块里面的语句都会被执行。当在try或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。



以下4中特殊情况，finally块不会被执行。

1.在finally语句块第一行发生了异常。因为在其他行，finally块还是会得到执行。

2.前面的代码中用到了System.exit(int)已退出程序。exit是带参函数，若该语句在异常语句之后，finally会执行。

3.程序所在的线程死亡。

4.关闭CPU。



**注意：** 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。

```java
public static int f(int value){
    try{
        return value * value;
    }finally{
        if (value == 2){
            return 0;
        }
    }
}
```

如果调用 `f(2)`，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。



**Java序列化中如果有些字段不想进行序列化，怎么办？**

对于不想进行序列化的变量，使用transient关键字修饰。

transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。



**获取用键盘输入常用的两种方法**

方法1：通过Scanner

```java
import java.util.*;

Scanner scan = new Scanner(System.in);
String s = scan.nextLine();
scan.close();
```

方法2：通过BufferedReader

```java
import java.io.*;

public void func() throws IOException{
    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
    String s = bf.readLine();
}
```



**Java 中 IO 流**

Java中的IO流分几种：

1.按照流的流向分，可以分为输入流和输出流；

2.按照操作单元分，可以分为字节流和字符流；

3.按照流的角色，划分为节点流和处理流。



Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系。 Java IO流的40多个类都是从如下4个抽象类基类中派生出来的。

1.InputStream/Reader。所有的输入流的基类，前者是字节输入流，后者是字符输入流。

2.OutputStream/Writer。所有输出流的基类，前者是字节输出流，后者是字符输出流。



按照操作方式分类：

![](https://img2018.cnblogs.com/blog/1119873/201911/1119873-20191104184110388-848498732.png)



按照操作对象分类：

![](https://img-blog.csdnimg.cn/img_convert/c98b2d58e55f2202696b82a3bca05d16.png)



**既然有了字节流，为什么还要有字符流?**

问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？

字符流是有是由JVM将字节转换得到的，问题就出在这个过程还十分耗时，并且如果我们不知道编码类型就很容易出现乱码问题。所以，IO流就干脆提供了一个直接操作字符的接口，方便我们对字符进行流操作。比如音频、图片等媒体文件用字节流比较好，如果涉及到字符的话，使用字符流比较好。



**BIO，NIO，AIO有什么区别?**

（1）BIO（Blocking I/O）。同步阻塞IO模式。**数据的读取写入必须阻塞在一个线程内等待其完成**。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。

（2）NIO（New I/O，也可以理解为Non-Blocking I/O）。NIO是一种同步非阻塞的IO模型。在Java 1.4 中引入了NIO框架，对应 java.nio 包，**提供了 Channel , Selector，Buffer等抽象**。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。

阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。

（3）AIO（Asynchronous I/O）。AIO也就是NIO2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。**异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作**。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。



**深拷贝 vs 浅拷贝**

（1）浅拷贝。对基本数据类型进行值传递；对引用数据类型进行引用传递般的拷贝，多个引用指向同一个对象。

（2）深拷贝。对基本数据类型进行值传递；对引用数据类型，创建一个新对象，并复制其内容。



##### Java I/O #####

---

Java 的 I/O 大概可以分成以下几类：

- 磁盘操作：File
- 字节操作：InputStream 和 OutputStream
- 字符操作：Reader 和 Writer
- 对象操作：Serializable
- 网络操作：Socket
- 新的输入/输出：NIO



一、磁盘操作

File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。

递归地列出一个目录下所有文件：

```java
public static void listAllFiles(File dir){
    if (dir == null || !dir.exists()){
        return;
    }
    if (dir.isFile()){
        System.out.println(dir.getName());
        return;
    }
    for (File file: dir.listFiles()){
        listAllFiles(file);
    }
}
```

从 Java7 开始，可以使用 Paths 和 Files 代替 File。



二、字节操作

实现文件复制

```java
public static void copyFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutputStream(dist);

    byte[] buffer = new byte[20 * 1024];
    int cnt;

    // read() 最多读取 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof，即文件尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }

    in.close();
    out.close();
}
```



装饰者模式

Java I/O使用了装饰者模式来实现。以InputStream为例：

- InputStream 是抽象组件；
- FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；
- FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。

实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。

```java
FileInputStream fileInputStream = new FileInputStream(filePath);
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
```

DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。







#### 计算机网络 ####

---

位：bit，比特

字节：byte

1 byte = 8 bit（一个字节 等于 8个比特）



##### 概述 #####

---

ISP，互联网服务提供商。可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。



**主机之间的通信方式**

（1）C/S（客户端-服务器）。客户端是服务的请求方，服务器是服务的提供方。

（2）P2P（点对点，对等）。不区分客户端和服务器。



**电路交换和分组交换**

（1）电路交换。电路交换用于电话通信系统，两个用户要通信之前需要**建立一条专用的物理链路**，并且在整个通信过程中**始终占用该链路**。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。

（2）分组交换。每个分组都有首部和尾部，包含了源地址和目的地址等控制信息。在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。

在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。（每隔一段时间转发一次，**存储转发**才使得路由器中产生了处理时延）



**时延**

总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延

（1）排队时延

分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。

（2）处理时延

主机或路由器收到分组时进行处理所需要的时间。例如分析首部、从分组中提取数据、进行差错检验或查找适当地路由等。

（3）传输时延

主机或路由器传输数据帧所需要的时间。
$$
delay = \frac{l(bit)}{v(bit / s)}
$$
其中l表示数据帧的长度，v表示传输速率。

（4）传播时延

电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。
$$
delay = \frac{l(m)}{v(m / s)}
$$
其中l表示信道长度，v表示电磁波在信道上的传播速度（接近光速）。



**计算机体系结构**

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" style="zoom:67%;" />

1.OSI和TCP/IP是真实存在的，而五层协议是我们综合二者的优势总结而成的。这里我们说一下五层协议。

（1）应用层。为特定的应用程序提供数据传输服务，例如HTTP、DNS等协议。数据单位为**报文**。

（2）传输层。为**进程**提供通用数据传输服务。由于应用层协议太多，定义通用的传输层协议就可以支持不断增多的应用层协议。传输层包括两种协议：传输控制协议（TCP），提供面向连接、可靠的数据传输服务，数据单位为**报文段**；用户数据报协议（UDP），提供无连接、尽最大努力的数据传输服务，数据单位为**用户数据报**。TCP主要提供完整性服务，UDP主要提供及时性服务。

（3）网络层。为**主机**提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成**分组**。

（4）数据链路层。网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成**帧**。

（5）物理层。考虑的是怎样在传输媒体上传输数据**比特**流，而不是指具体的传输媒体。物理层的作用是尽量可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。



2.OSI

其中表示层和会话层用途如下：

（1）表示层。数据压缩，加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题（编码问题）。

（2）会话层。建立及管理会话。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。



3.TCP/IP

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/48d79be8-085b-4862-8a9d-18402eb93b31.png" style="zoom:67%;" />

TCP/IP体系结构不严格遵循OSI分层概念，应用层可能会直接使用IP层或网络接口层。



**数据在各层之间的传递过程**

在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。

路由器只有下三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。



##### 物理层 #####

---

通信方式：根据信号的传输方向分为三种，单工信道、半双工、全双工。

带通调制：模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。



##### 数据链路层 #####

---

封装成帧：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/29a14735-e154-4f60-9a04-c9628e5d09f4.png" style="zoom:67%;" />

透明传输：如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。（这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。）

差错检测：目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。



##### 网络层 #####

---

因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。

使用IP协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。



与 IP 协议**配套**使用的还有三个协议：

- ARP和RARP，地址解析协议（Address Resolution Protocal）；
- ICMP，网际控制报文协议（Internet Control Message Protocal）；
- IGMP，网际组管理协议（Internet Group Management Protocal）。



**IP数据报格式**

- **版本**：有IPv4和IPv6两个版本；
- 首部长度：占 4 位（4 byte，也就是 32 bit），因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。
- 区分服务：用来获得更好的服务，一般情况下不使用。
- **总长度**：包括首部长度和数据部分长度；
- **生存时间**：TTL（最大跳数），它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器的跳数为单位，当TTL为0时就丢弃数据报。
- **协议**：指出携带的数据应该上交给哪个协议进行处理，例如ICMP，TCP，UDP等。
- **首部检验和**：因为数据每经过一个路由器，都要重新计算检验和，因此检验和不包含数部分可以减少计算的工作量。
- **标识**：在数据报长度过长而发生分片的情况下，相同数据报的不同分片具有相同的标识符。
- **片偏移**：和标识符一起，用于发生分片的情况。片偏移的单位为8字节。



**IP地址编址方式**

IP地址编址方式经历了三个历史阶段：

- 分类
- 子网划分
- 无分类



1.分类

由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。

IP 地址 ::= {< 网络号 >, < 主机号 >}



2.子网划分

通过在主机号字段中拿一部分作为子网号，把两级IP地址划分为三级IP地址。

IP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}

要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 **11**000000 00000000，也就是 255.255.192.0。

注意，外部网络看不到子网的存在。



3.无分类

无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

IP 地址 ::= {< 网络前缀号 >, < 主机号 >}

无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

IP 地址 ::= {< 网络前缀号 >, < 主机号 >}

CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。

CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。

一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为**路由聚合**，也称为 **构成超网** 。

在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。



**地址解析协议 ARP**

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。

ARP 实现由 IP 地址得到 MAC 地址。

每个主机都有一个ARP高速缓存，里面有本局域网上的各主机和路由器的IP地址到MAC地址的映射表。

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。



**网际控制报文协议 ICMP**

ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。

ICMP 报文分为**差错报告报文**和**询问报文**。



1.Ping

Ping是ICMP的一个重要应用，主要用来测试两台主机之间的连通性。

Ping的原理是通过向目的主机发送ICMP Echo请求报文，目的主机收到之后会发送Echo回答报文。Ping会根据时间和成果响应次数估算出数据包往返时间以及丢包率。



2.Traceroute

Traceroute是ICMP的另一个应用，用来跟踪一个分组从源点到终点的路径。

Traceroute发送的IP数据报封装的是无法交付的UDP用户数据报，并由目的主机发送终点不可达差错报告报文。

- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文（当traceroute发送的UDP datagrams到达目的地时，由于它的port number是一个一般应用程序都不会用的号码，比如30000，所以此UDP datagrams到达目的地后送回一个ICMP port unreachable的消息，而当traceroute收到消息时，便知道目的地已经到达了）。
- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。



**虚拟专用网 VPN**

由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。

有三个专用地址块：

- 10.0.0.0 ~ 10.255.255.255
- 172.16.0.0 ~ 172.31.255.255
- 192.168.0.0 ~ 192.168.255.255

VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。

下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。



**网络地址转换 NAT**

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。

​		在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。



NAT和内网穿透

​		NAT只会接受在Track table中有ip和端口记录的外部访问，其他的都一概不转发，这也就是我们常说的**NAT只能内网访问外网，不能外网访问内网**。



假设现在有内网客户端A和内网客户端B，有公网服务端S。
如果A和B想要进行**UDP**通信（TCP的话有所不同），则必须穿透双方的NAT路由。假设为NAT-A和NAT-B。

内网穿透（打洞原理）：A向B的公网IP发送一个数据包，则NAT-A能接收来自NAT-B的数据包并转发给A了（即B现在能访问A了）；再由S命令B向A的公网IP发送一个数据包，则NAT-B能接收来自NAT-A的数据包并转发给B了（即A现在能访问B了）。

参考 https://www.cnblogs.com/jiading/p/12029450.html



**路由器的结构**

路由器从功能上可以划分为：路由选择和分组转发。

分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。



**路由器分组转发流程**

- 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。
- 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；
- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
- 报告转发分组出错。



**路由选择协议**

路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。

互联网可以划分为许多较小的自治系统（Autonomous System，AS），一个 AS 可以使用一种和别的 AS 不同的路由选择协议。

可以把路由选择协议划分为两大类：

- 自治系统内部的路由选择：RIP 和 OSPF
- 自治系统间的路由选择：BGP



1.内部网关协议 RIP

RIP 是一种基于**距离向量**的路由选择协议。**距离是指跳数**，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。

RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。

距离向量算法（可以参考 https://blog.csdn.net/lf_2016/article/details/60468264 更加容易理解）：

- 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；
- 对修改后的 RIP 报文中的每一个项目，进行以下步骤：
- 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；
- 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。
- 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。

RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。



2.内部网关协议 OSFP

OSPF（Open Shortest Path First开放最短路径优先），是为了克服 RIP 的缺点而开发出来的。

开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。

OSPF 具有以下特点：

- 向本自治系统中的所有路由器发送信息，这种方法是**洪泛法**。
- 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
- 只有当链路状态发生变化时，路由器才会发送信息。

所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。



3.外部网关协议 BGP

BGP（Border Gateway Protocol，边界网关协议）

AS 之间的路由选择很困难，主要是由于：

- 互联网规模很大；
- 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
- AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

BGP只能寻找一条比较好的路由，而不是最佳路由。

每个AS（自治系统）都必须配置BGP发言人，通过在两个相邻BGP发言人之间建立TCP连接来交换路由信息。



##### 传输层 #####

---









##### 应用层 #####

---







**POST和GET**



**URL请求流程**

URL（统一资源定位符），用于互联网上不同资源的标识，就像不同的人有不同的身份证一样。

URL的组成分为3个部分：协议 + 域名 + 端口

<img src="https://upload-images.jianshu.io/upload_images/3635292-38ae564a1b91b0ae.png?imageMogr2/auto-orient/strip|imageView2/2/w/454/format/webp" style="zoom:67%;" />

---

这里与套接字（Socket）做一个对比。

​		所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口。



​		Socker的组成分为2个部分：IP + 端口。



​		要通过互联网进行通信，至少需要一对套接字，其中一个运行于客户端，我们称之为 Client Socket，另一个运行于服务器端，我们称之为 Server Socket。根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤：

1.服务器监听：所谓服务器监听，是指服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。

2.客户端请求：所谓客户端请求，是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端接字提出连接请求。

3.连接确认：所谓连接确认，是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，就会响应客户端套接字的请求，建立一个新的线程，并把服务器端套接字的描述发送给客户端。一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，接收其他客户端套接字的连接请求。



|              | URL                        | Socket                         |
| ------------ | -------------------------- | ------------------------------ |
| 组成         | 协议 + 域名 + 端口         | IP + 端口                      |
| 应用场景     | B/S框架（浏览器/服务器）   | C/S框架（客户端/服务器）       |
| 作用于哪一层 | 应用层（因为使用HTTP协议） | 传输层、网络层（涉及到IP地址） |



**Socket与URL通信比较**
		利用socket进行通信时，在服务器端运行一个socket通信程序。服务器端不停地监听某个端口，等待客户的连接申请，接到申请后建立连接并进行通信，所以，在socket通信方式中，服务器是**主动**等待连接通信的到来。 
		利用URL进行通信时，在服务器端常驻一个CGI程序，但它一直处于休眠状态。只有在客户端要求建立连接时才被激活，然后与用户进行通信。所以，在URL通信方式中，服务器是**被动**等待连接通信的到来。 
		由于URL通信和socket通信的方式不同，所以，它们有各自的特点。利用socket进行通信时，服务器端的程序可以打开多个线程与多个客户进行通信，还可以通过服务器使各个客户之间进行通信。这种方式比较灵活，适用于一些较复杂的通信，但是服务器端的程序必须始终处于运行状态以监听端口。利用URL进行通信时，服务器端的程序只能与一个客户进行通信，形式比较单一。但是它不需要服务器端的CGI程序一直处于运行状态，只是在有客户申请时才被激活。所以，这种方式比较适用于客户机的浏览器与服务器之间的通信。

---



URL一次请求过程如下：

1.域名解析。

浏览器搜索DNS缓存（维护一张域名与IP地址的对应表），如果**查到域名对应的IP**，就发送和接收参数和数据；

若没有，则搜索操作系统中的DNS缓存（维护一张域名与IP地址的对应表）；

若没有，则搜索操作系统下的hosts文件；

若没有，则操作系统发送域名至本地域名服务器（**递归**查询方式），本地域名服务器查询自己的DNS缓存。查找成功则返回结果，若没有，则进行以下**迭代**查询：

​	**本地域名服务器**向根域名服务器（包含com, net, org等）发起请求，查询域名对应的IP；

​	**本地域名服务器**向com域的顶级域名服务器发起请求；

​	**本地域名服务器**向baidu.com权限域名服务器发起请求。

**本地域名服务器**将得到的IP地址返回给操作系统，同时自己也将IP地址缓存起来；

操作系统将 IP 地址返回给浏览器，同时自己也将IP地址缓存起来。至此，浏览器已经得到了域名对应的IP地址；



2.三次握手

建立TCP连接后发起HTTP请求。HTTP的浏览器缓存机制。使用POST还是GET。



3.服务器接收到请求并相应HTTP请求

负载均衡。网站可能会有负载均衡设备来平均分配所有用户的请求。即对工作任务进行平衡，分摊到多个操作单元上执行，如图片服务器，应用服务器等；

请求处理阅读请求及它的参数和cookie。



4.浏览器解析代码（html, js, css）

看是否是长连接，来决定是不是断开TCP连接。



5.断开TCP连接

四次挥手。



6.浏览器对页面进行渲染呈现给用户



**IP地址分类**





**TCP和UDP的区别**

​		TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个，之所以命名为TCP/IP协议，因为TCP、IP是两个很重要的协议，所以就用它两命名了。



TCP/IP协议集包括应用层，传输层，网络层，数据链路层。

（1）应用层协议包括：

1.超文本传输协议（HTTP）：万维网的基本协议；

2.文本传输（TFTP简单文件传输协议）；

3.远程登录（Telnet）：提供远程访问其它主机功能，它允许用户登录internet主机，并在这台主机上执行命令；

4.网络管理（SNMP简单网络管理协议）：该协议提供了监控网络设备的方法，以及配置管理，统计信息收集，性能管理及安全管理等；

5.域名系统（DNS）：该系统用于在Internet中将域名及其域名及其公共广播的网络节点转换成IP地址。



（2）网络层协议包括：

1.Internet协议（IP）；

2.Internet控制信息协议（ICMP）；

3.地址解析协议（ARP）；

4.反向地址解析协议（RARP）。



（3）数据链路层：

​		数据链路层又称作主机到网络层（host-to-network），数据链路层的功能包括IP地址与物理地址硬件的映射，以及将IP封装成帧。基于不同硬件类别的网络接口，数据链路层定义了物理介质的连接。（这里只是简单概括，并不够完善）。



**先说说TCP**

​		TCP（Transmission Control Protocal，传输控制协议），是面向连接的协议，也就是说，在收发数据前，必须先和对方建立可靠的连接。

**一个TCP连接必须要经过3次“对话”才能建立起来**，简单描述如下：

1.主机A向主机B发送连接请求数据包：“我想发给你数据，可以吗？”，这是第一次对话；

2.主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候开始发？”，这是第二次对话；

3.主机A再发出一个数据包确认主机B的同步要求：“我现在就发，你接着吧！“，这是第三次对话。

三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”后，主机A才向主机B正式发送数据。



**TCP的三次握手和四次挥手**

概括如下：

（1）3次握手过程

第一次握手：主机A通过向主机B发送一个含有同步序列号（SYN）的标志位的数据段，向主机B请求连接，通过这个数据段，主机A告诉主机B两件事：我想要和你通信；尽可以用哪个序列号作为起始数据段来回应我。

第二次握手：主机B收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用哪个序列号作为起始数据段来回应我。

第三次握手：主机A收到这个数据段后，再发送一个确认应答（ACK），确认已收到主机B的数据段：我已经收到回复了，现在要开始传输实际数据了。如此，3次握手便完成了，主机A和主机B可以传输数据了。

三次握手的特点：没有应用层的数据，SYN这个标志位只有在TCP建立连接时才会被置1，握手完成后，SYN标志位被置0。

<img src="https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:67%;" />



（2）4次挥手过程

第一次挥手：当主机A完成数据传输后，将控制为FIN置1，提出停止TCP连接的请求；

第二次挥手：主机B收到FIN后对其作出相应，确认这一方向上的TCP连接将关闭，将ACK置1；

第三次挥手：由B端再次提出反方向的关闭请求，将FIN置1；

第四次挥手：主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。



**总结：**由TCP的三次握手和四次挥手可以看出，TCP使用面向连接的通信方式，大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传播前就有了交互，为数据正式传播打下了可靠的基础。

<img src="https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:67%;" />



名词解释：

1.ACK。ACK是TCP报头的控制位之一，对数据进行确认。确认由接收端发出，用它来告诉发送端这个序列号之前的数据段都收到了。比如确认号为x，表示前x-1个数据段都收到了，只有当ACK=1时确认号才有效，当ACK=0时确认号无效，这时会要求重传数据，保证数据的完整性。

2.SYN。同步序列号，TCP建立连接时将这个置1.

3.FIN。发送段完成发送任务位，当TCP完成数据传输需要断开时，提出断开连接的一方将这一位置为1。



**常见的问题**以及详细情况，参考 https://www.cnblogs.com/bj-mr-li/p/11106390.html



**UDP（User Data Protocal，用户数据报协议）**

1.UDP是一个非连接的协议，传输数据之前发送端和接收端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输宽带的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

2.由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务器可同时向多个客户机传输相同的消息。

3.UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。

4.吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、发送端的接收端主机性能的限制。

5.UDP尽最大努力交付，即不保证可靠交付，因此主机不需要为维持复杂的连接状态表（其中包含许多参数）。

6.UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层，既不拆分也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。



注意：ping命令是用来探测主机到主机之间是否可通信，如果不能ping到某台主机，表明不能和这台主机建立连接。ping命令是使用IP和ICMP（网络控制信息协议），虽然理论上是和TCP，UDP处于同一级别，但是没有涉及任何传输协议（TCP，UDP）和应用程序。ICMP协议规定：接收端主机必须返回ICMP的回送应答消息给发送端主机，如果发送端主机在一定时间内收到应答，则认为主机可达。



**TCP和UDP的比较**

1.基于连接和无连接；

2.对系统资源的要求（TCP较多，UDP较少）；

3.UDP程序结构较简单；

4.流模式与数据报模式（参考 https://blog.csdn.net/peanutwzk/article/details/79999936）；

5.TCP保证数据正确性（可靠），UDP可能丢包（不可靠，但也是尽最大努力）；

6.TCP保证数据顺序，UDP不保证。

7.TCP传输大量数据，但传输速度慢，UDP传输少量数据，传输速度快。



**网卡是什么**

　　计算机与外界局域网的连接是通过主机箱内插入一块网络接口板(或者是在笔记本电脑中插入一块PCMCIA卡)。网络接口板又称为通信适配器或网络适配器(adapter)或网络接口卡NIC(Network Interface Card)但是现在更多的人愿意使用更为简单的名称“网卡”。

　　网卡是工作在数据链路层的网路组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。



网卡的主要功能有以下三个：

**功能1.数据的封装与解封**

　　发送时将上一层交下来的数据加上首部和尾部，成为以太网的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层。

**功能2.链路管理**

　　主要是CSMA/CD（Carrier Sense Multiple Access with Collision Detection ，带冲突检测的载波监听多路访问）协议的实现。

**功能3.编码与译码**

　　即曼彻斯特编码与译码。







##### Socket #####

---

一、I/O模型

一个输入操作通常包括两个阶段：

- 等待数据准备好

- 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常是涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核的缓冲区复制到应用进程缓冲区。



Unix有五种I/O模型：

- 阻塞式（BIO）
- 非阻塞式（NIO）
- **I/O复用（select和poll）**
- 信号驱动式I/O（SIGIO）
- 异步I/O（AIO）



**阻塞式I/O**

应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。

应该注意到，在阻塞的过程中，其他应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他应用进程还可以执行，所有不消耗CPU时间，这种模型的CPU利用率会比较高。

recvfrom()函数如下，用于接收Socket传来的数据，并复制到应用进程缓冲区buf中。这里把recvfrom()当做系统调用。

```c
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
```



**非阻塞式I/O**

应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断地执行系统调来获知I/O是否完成，这种方式称为轮询（polling）。

由于CPU要处理更多的系统调用，因此这种模型的CPU利用率比较低。



**I/O复用**

使用select或者poll等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核缓冲区复制到应用过进程缓冲区中。

它可以让单个进程具有处理多个I/O事件的能力。又被称为Event Driven I/O，即事件驱动I/O。

如果一个web服务器没有I/O复用，那么每一个Socket连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比多进程和多线程技术，I/O复用不需要进程线程创建和切换的开销，系统开销更小。



**信号驱动I/O**

应用进程使用sigaction系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送SIGIO信号，应用进程收到之后在信号处理程序中调用recvfrom将数据从内核复制到应用进程中。

相比于非阻塞I/O的轮询方式，信号驱动I/O的CPU利用率更高。



**异步I/O**

应用进程执行aio_read系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

异步I/O与信号驱动I/O的区别在于，异步I/O的信号是通知应用进程I/O**完成**，而信号驱动I/O的信号是通知应用进程可以**开始I/O**。



五大模型比较

- 同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞；
- 异步I/O：第二阶段应用进程不会阻塞。

同步I/O包括：阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在于第一阶段。

非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。



二、I/O复用

select, poll, epoll 都是I/O多路复用的具体实现，select出现的最早，之后是poll，再是epoll。



**select**

```c
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

select允许应用程序监视一组文件描述符，等待一个或者多个描述符称为就绪状态，从而完成I/O操作。

- fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有3种类型的描述符：readset, writeset, exceptset，分别对应读，写，异常条件的描述符集合。
- timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过timeout。
- 成功调用返回结果大于0，出错返回结果为-1，超时返回结果为0。

```c
fd_set fd_in, fd_out;
struct timeval tv;

// Reset the sets
FD_ZERO( &fd_in );
FD_ZERO( &fd_out );

// Monitor sock1 for input events
FD_SET( sock1, &fd_in );

// Monitor sock2 for output events
FD_SET( sock2, &fd_out );

// Find out which socket has the largest numeric value as select requires it
int largest_sock = sock1 > sock2 ? sock1 : sock2;

// Wait up to 10 seconds
tv.tv_sec = 10;
tv.tv_usec = 0;

// Call the select
int ret = select( largest_sock + 1, &fd_in, &fd_out, NULL, &tv );

// Check if select actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    if ( FD_ISSET( sock1, &fd_in ) )
        // input event on sock1

    if ( FD_ISSET( sock2, &fd_out ) )
        // output event on sock2
}
```



**poll**

```c
int poll(struct pollfd *fds, unsigned int nfds, int timeout);
```

poll的功能与select类似，也是等待一组描述符中的一个称为就绪状态。

poll中的描述符是pollfd类型的数组，pollfd的定义如下：

```c
struct pollfd {
	int   fd;         /* file descriptor */
	short events;     /* requested events */
	short revents;    /* returned events */
};
```

```c
// The structure for two events
struct pollfd fds[2];

// Monitor sock1 for input
fds[0].fd = sock1;
fds[0].events = POLLIN;

// Monitor sock2 for output
fds[1].fd = sock2;
fds[1].events = POLLOUT;

// Wait 10 seconds
int ret = poll( &fds, 2, 10000 );
// Check if poll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // If we detect the event, zero it out so we can reuse the structure
    if ( fds[0].revents & POLLIN )
        fds[0].revents = 0;
        // input event on sock1

    if ( fds[1].revents & POLLOUT )
        fds[1].revents = 0;
        // output event on sock2
}
```



select和poll比较

1.功能

select和poll的功能基本相同，不过在一些实现细节上有所不同。

- select会修改描述符，而poll不会；
- select的描述符使用数组实现，FD_SETSIZE 大小默认为1024，因此默认只能监听少于1024个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而poll没有描述符数量的限制；
- poll提供了更多的事件类型，并且对描述符的重复利用比select高；
- 如果一个线程对某个描述符调用select或者poll，另一个线程关闭了该描述符，会导致调用结果不确定。



2.速度

select和poll的速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。



3.可移植性

几乎所有的系统都支持select，但是只有比较新的系统支持poll。



**epoll**

```c
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

​		epoll_ctl() 用于向内核注册新的描述符，或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将I/O准备好的描述符加入到一个链表中管理，进程调用epoll_wait() 便可以得到事件完成的描述符。

​		从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过**轮询**（非阻塞I/O中，应用进程继续执行，但需要不停地执行系统调用来获知I/O是否完成）来获得事件完成的描述符。

```c
// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.
// The function argument is ignored (it was not before, but now it is), so put your favorite number here
int pollingfd = epoll_create( 0xCAFE );

if ( pollingfd < 0 )
 // report error

// Initialize the epoll structure in case more members are added in future
struct epoll_event ev = { 0 };

// Associate the connection class instance with the event. You can associate anything
// you want, epoll does not use this information. We store a connection class pointer, pConnection1
ev.data.ptr = pConnection1;

// Monitor for input, and do not automatically rearm the descriptor after the event
ev.events = EPOLLIN | EPOLLONESHOT;
// Add the descriptor into the monitoring list. We can do it even if another thread is
// waiting in epoll_wait - the descriptor will be properly added
if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1->getSocket(), &ev ) != 0 )
    // report error

// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)
struct epoll_event pevents[ 20 ];

// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array
int ready = epoll_wait( pollingfd, pevents, 20, 10000 );
// Check if epoll actually succeed
if ( ret == -1 )
    // report error and abort
else if ( ret == 0 )
    // timeout; no event detected
else
{
    // Check if any events detected
    for ( int i = 0; i < ready; i++ )
    {
        if ( pevents[i].events & EPOLLIN )
        {
            // Get back our connection pointer
            Connection * c = (Connection*) pevents[i].data.ptr;
            c->handleReadEvent();
         }
    }
}
```



相比前面的select和poll

- epoll 仅适用于 Linux OS。
- epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。
- epoll 对多线程编程更友好，一个线程调用了epoll_wait()，另一个线程关闭了同一个描述符也不会产生像select和poll的不确定情况。



工作模式

epoll 的描述符事件两种触发模式：LT（level trigger）和ET（edge trigger）。

1.LT模式

当epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用epoll_wait()会再次通知进程。是默认的一种模式，并且同时支持Blocking和No-Blocking。



2.ET模式

和LT模式不同的是，通知之后进程必须立即处理该事件，下次再调用epoll_wait()时不会再得到事件到达的通知。

很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。只支持No-Blocking，以避免由于一个文件句柄的阻塞 读/写 操作把处理多个文件描述符的任务饿死。



应用场景

很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。

1.select应用场景

select的timeout参数精度为微妙，而poll和epoll为毫秒，因此select更加适用于实时性要求比较高的场景，比如核反应堆的控制。

select可移植性更好，几乎被所有主流平台所支持。



2.poll应用场景

poll没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用poll而不是select。



3.epoll应用场景

只需要运行在linux平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。

需要同时监控小于1000个描述符，就没有必要使用epoll，因为这个应用场景下并不能体现 epoll 的优势。

需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用epoll。因为epoll中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过epoll_ctl()进行系统调用，频繁系统调用降低效率。并且epoll的描述符存储在内核，不容易调试。





#### 操作系统 ####

---

**死锁及条件**





**银行家算法**







#### Linux和Git常用操作 ####

---







#### 参考 ####

---

JavaGuide https://snailclimb.gitee.io/

CSNode http://www.cyc2018.xyz/

Interview-site-Lan https://github.com/MikeCreken/Interview-site-Lan

全部汇总 https://blog.csdn.net/weixin_44934424/article/details/115066562





